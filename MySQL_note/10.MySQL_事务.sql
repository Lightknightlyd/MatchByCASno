

###################################################################
############################################################  事务

MySQL事务的理解：
一个或多个SQL语句构成一个不可分割的整体一起执行，
如果其中某条SQL执行失败，整个单元将会回滚，回到事务开始前的状态。

注意：MyISAM类型表不支持事务，只能通过伪事务实现处理

事务的结果只在其被完全执行时才能看见，完成之前其结果是不被公布的


//初始化事务
start transaction; //不会给出提示的，没有告警或错误提示，说明事务初始化成功

//创建事务
insert ... // 插入数据，修改数据等等...

//提交事务
commit;

//回滚
rollback //当已经创建事务并执行了一些SQL时，想要撤销之前的所有操作
实际上，如果用户没有提交事务，则会默认自动回滚


# 设置是否自动提交

set AUTOCOMMIT=0; //不自动提交
SELECT @@AUTOCOMMIT; //显示状态


# 事务的4种孤立级
多用户时，不同事务如何互不影响
1、序列化 只有当事务提交后，用户才能从数据库看到数据的变化
2、可重读 幻读
3、提交后读 幻读+不可重复读
4、未提交读 脏读+幻读+不可重复读

脏读：事务A未提交时，事务B修改数据，事务A读到事务B的数据，然后B回滚，那么未提交的事务A读到的就是脏数据
不可重复读： 事务A未提交时，事务B修改数据并提交后，事务A才能读到B的数据，导致事务A多次读取时结果不一致
幻读： 当事务A处理时，事务B修改了数据，使得事务A处理完后发现还有新的处理没被处理

不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

可重复读的隔离级别下使用了MVCC机制，select操作是历史数据；insert、update和delete则基于当前真实数据。




# 修改事务孤立级
select @@tx_isolation; //查看当前孤立级值
set global transaction isolation level read committed;

# 事务和性能

不同孤立级的失误可能会对系统造成一系列影响

# 死锁

当两个或多个处于不同序列的用户打算同时更新相同的数据库时，因互相等待对方释放权限而
导致双方一直处于等待状态。

不过InnoDB表处理程序具有检查死锁这一功能，如果产生死锁，该程序会撤销其中一个事务


# 伪事务
用表锁代替事务
因为事务只支持innoDB表，而不支持MyISAM类型表，因此对于后者可用伪事务

由于没有事务，当用户进行插入、删除等操作时，数据会立即变化，这样在多用户环境中会导致问题
解决方法是用表锁定使得在操作时不会受到其他用户干扰

步骤：
# 为指定数据表添加锁定
lock tables table_name lock_type // lock_type有read和write//read：所有用户只能读不能写，write当前用户可以读可以写，其他用户不能读不能写

#数据操作
insert ...

# 解锁
unlock tables;

## 应用表锁实现伪事务

MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，
在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁
read local 只在本地加读锁，其他线程仍可写入

